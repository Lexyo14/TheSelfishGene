Welcome to the program Selfish Gene. The software assesses the population's stability over a particular period of time. Please enter the necessary parameters into the application or select the Default Population option to continue.

Class Battle

This class is where we set all the initial conditions for the population as fields; such as the values a,b, and c, these values will help us determine the health level of each population type in the future, the life expectancies of the members of the population from which they will die out if they reach this value, the stability value that determines when stability has been reached by our program and return the result, the span of one generation, this value will tell us for how long one generation will survive before they all die out and are replaced by another generation, an additional approximate value that we will add to our "ideal ratio", which will be defined later, and used to check if teh ratios of teh popution in the current state is aproximatly within the range of the ideal ratio, the ratio value this will be the returned value if our program reaches stability, and a mut value that if the value of muattion(which will be a variabel we will define in the future) is less than this value there will be a mutation hence the offsprings of the parents might not necessarily be of the same type as their parents.

We start by creating 4 stacks two of which are for men, one stack will be used for both the faithful and philanderer types and the other stack will be used as a temporary stack for the males that have died out, We will accumulate them here for now and remove them later. And two stacks for women. Similarly, we use one stack for both types of women coy and fast, and the other as a temporary stack to store the women that have died out. Later on, we will define how a person dies out. Men and women are classes that we will get to later.

We have also set counters for each type member of the population as well as an array of float numbers in which we will store the ratio of each type to the population at that particular time. We can think of a generation as an “attempt” to stabilize. We had mentioned that we have given an initial generation span as an input, so we will play it out with this span and upon calculating the ratios at the end if they have reached the stability value that we had also provided as an input, then we will return the ration if not then we will clear all the stacks and start afresh.--- that is what we mean by generation.


We now define a method named “exe” that takes all the parameters that we have pointed out at the beginning and assigns all the input values to their respective fields. Additionally, it will take the total number of coy, faithful, fast, and philanderer we want it to start with. This way we can change the number of citizens of each type in each generation to see how it can affect the stability condition. Since when we run this method it will create a new generation, we always have to start by clearing the stacks that we have.
After we have set all our variables and put them in their respective fields, it's time to spawn our population members. We will use for loops and set an I value to 0 until the max number of coy, philanderer, fast, faithful people we have provided as a parameter upon calling this method and with each iteration, we will create an attribute of coy, philanderer, fast, and faithful respectively and add them to their respective stack. That is the coy and fast go to the stack of type women and the philanderer and faithful will go to the stack of type men.

At this point, we will create a new list of ratios. This will be our ideal ratio in which later on we will calculate the ratio again and compare it to this ratio to check the stability. The way we calculate this ratio is we take the total number of people we have allowed for each respective type and we divide it by the total number of population which is the sum of all the respective types and multiply it by 100.
We will set a counter named stable, that will increase in value if after a generation the ratios are found to be compatible with the initial ideal ratio that we have defined.

Now we will implement a for loop that sets a value j from 0 to rep, rep being the total number of generations allowed in one cycle and with each iteration, we will count the number of women and men in the stack and assign it to the maxw and maxm variables respectively. Our next task is to turn all the men into threads we do this by implementing a nested for loop and assigning another variable k that goes from 0 till maxm and with each iteration, it will extract the kth man from the stack and assign it to a variable of type men. then we will create an attribute of thread and as an input parameter, we will input this variable of type men that now contains within it the man that we had just extracted from the man stack.

At this point, it is time to remove all the died-out men and women from our temporary stack(we will see later the exact point where we added these died-out population members and how we decided their death) to do this we will implement a for each loop that will assign a variable of type men/ women to the stack tempm/tempw respectively and remove said variable from the stack. We must also decrease the counter of each population type we have hence we must check what type the died-out person is. Then after we have finished removing all the people in the temp stacks from the stack we will just clear the temporary stacks for the next generation. After each generation, we must check the stability by comparing the new ratio to the ideal ratio. We will only add one point to the stable variable if all four ratios are compatible with the ideal ratios. Hence we will use four for loops to implement this in which we will take for example the ideal ratio of coy and we will add and subtract from it the approximation value we have initially set. Due to some mutations, there might be a fluctuation in the population number hence we have given ourselves this value to balance it out. Our new coy ratio after this generation has to be in between these values. We will increment the stable value by one if and only if they hold for all four of the types.

after some generations, if the stable variable value is greater than or equal to the stability value, then it will return the current ratio if not then it will return unstable.

There will be different classes for men and women as well as the different types of the gender, in total 6 classes, that will allow us to assign functions and identities(id) to the said type of person. When we categorize them into 2 groups which are men and women, we can say that men have in total 3 classes that are Men, and the 2 types philanderer and faithful.

Class women

This class will be an interface providing all the methods that will need to be implemented by coy and fast to run the program such as their id value, a method to change their health, and a way to check their health. All these will, later on, be defined in the coy and fast classes.

Class coy, fast

These classes implement the interface for women. We provide an int variable health. This will be the deciding value if this particular person is going to die or not. We will need a way to decrease the health value so we will create a method that takes as an input a variable of type int and this will be negative, and it will represent the years this person has stayed alive for so after each generation we will decrease the year of this person. The method check health is used to see if the population members are still alive or not. The input parameter for this method will be the death value of the respective population member type that we have provided as a parameter when we created the population. In this method, we will check if the health of this particular member is less than its death value, if so it will return true else, false. later on, in the class "club" we will use this method and see how we can kill the members off. we will kill them and add them to the temp stack from which later on we will remove them iteratively from the main women stack. Each population type is going to have its unique id, this id value in the future depending on whom they meet with is going to determine in which case they fall in regarding copulating and it will determine their resources and ability to rare children. In the case of coy, the id was 1 and in fast the id is 2.

Class men

This class, like women, is also an interface providing all the methods that the philanderers and coy needs to execute their tasks. The first thing we do is to make sure Men contains runnable, therefore it’s an extension of runnable. This will allow all the instances of this class to be run as threads and we will need the instances of men to be threads whereas the women to be in the stack because we want to model the situation where the men go to the club and the women would have already been there. Similar to the women's class, this class will also contain an id method(that will be the unique identifier for faithful and philanderers), a change health method(which will allow us to decrease the health value as each year passes), and check health method.

Class faithful, philanderer

These classes, as the classes of coy and fast, are implementations of the methods found in the class women, They will be implementations of the class men in which we will provide the id of the respective type for which in the case of faithful its 6 and philanderer its 3, and implement the changing health and check health method. Additionally, we will provide a run BTS method that will override the run method found in the interface runnable which is the interface that the class men extend hence these subclasses will also extend the class runnable as they implement a class that extends it. In this method run, we will be creating an attribute of the club and providing as an input parameter, this particular thread (which is either faithful or philanderer). due to the constructor found in the class club, we can set an input parameter. This will put the men in the club and we will call the meet method on them to start the matching the outcome of said matching will be determined by the conditions that we have set in the class club and will be unique to each id type.

Class club

This class is going to be the place where we carry out the interaction between each type of the population and see how they behave. This class will extend the battel class hence it is a subclass and it will inherit all the methods and variables that we had defined in the class battle. In this class, we will create a man that will metaphorically go into the club to find a woman. We will set a constructor for this class that will take as input a variable of type men and this variable will be given to the field bf. The program, upon creating an attribute of the class men, since men extend two more classes philanderer/faithful, the program will pick one of these too to be the field bf it will inherit the contents of one of these classes including the id value which is unique to each class and we will be using this id value, later on, to decide which category of matching they belong under. We will define a method meet that will contain within its body all the outcomes of an interaction. Since in our model men are the ones that go to the club, we will assume that the females are already in the club waiting hence we will create a variable of type woman. Now we need to make sure the women's thread list is synchronized. If the man enters the club and it so happens to be empty( the amount of maxw is zero) then the man will just go home therefore we return nothing, else, we will take a random girl from the stack using a random index and we will remove that women from the stack with that index and assign it a variable we declared called gf of type women. After doing so we will decrease the total number of women by one and then add her back to the same list we had extracted her from only this time we are adding her to the end of the list hence she will not be a part of this generation again but she will be a part of the next generation.
after two people copulate, we will use a random number to decide if the offspring will be a boy or a girl in our case if it's odd it will be a girl if not it will be a boy. We will similarly define a random mutation variable that may result in the offspring being a different type from the parent.

We also need to randomly decide whether there will be a mutation or not. A mutation is when the offspring do not have the same characteristics as the parent. Upon starting this program we had provided a mut value that will be a value for which if the randomly generated number is less than this mut value then a mutation will occur. This will decide if the child will mutate or not and now we will randomly pick a number and assign it to a variable mutate and compare this variable to the initial mut value that we created.
After this, the next step will be doing the actual matchings between people. For this, we use the switch statement. Which will allow us to use the assigned IDs of the men and women types to do matching and to choose the one that applies. For example, if there is a matching between fast women and philanderer men, the id’s in total will be equal to 5 therefore case 5 will be used to calculate the result. In each class, we put the h1 and h2 parameters which will represent the health or resources these two people will have to rare the child, depending on the type of women and men this will vary. To decrease the health according to the relationship that was formed therefore the damage it had on the people involved. when we model the situation we will think of it as when the people meet or when we call the meet method on them then that will take a toll on their health because they have to give something to raise the child if they will have a child, hence after some time, we will decrease their health value.
Let us look at some cases as an example, the simple case is when the parents happen to be coy and philanderer in this case since both their health values are 0 then they can't have children thus we will break. Let's look at another case when it's fast and philander for example. Since the combined id of fast and philanderer is 5 it will go to the firth case and will carry out the following program.
Initially, it must set the health values and we will do so based on the formula that has been provided to us with the project description. In this case, h1 will be a-b and h2 will be a. having provided their health values we will now decide if there will be a mutation. If the randomly generated number “mutate” is less than the initially set number “mut” then there will be a mutation there for if the baby is a girl (whose gender will be decided by another random int variable that will be either 1 or two) the offspring will have the characteristic of the fast and if the offspring is a boy then he will have the characteristic of faithful.
in the case where the value "mutate" is greater than the mut value then that means that there will not be a mutation hence the offspring will take the characteristics of their parents.in both cases, after we have produced an offspring and given it its characteristics, we will add it back to the women's stack if it’s a daughter and to the men's stack if it’s a son then increases their respective counters.
And we repeat this pattern for each kind of couple(except for coy and philanderer)

After we have written all the cases and we have decided what couple goes where we must decrease the health of this bf and gf variables that we started with to see how much damage they have suffered from the relationship they have been in by how much a year is. This variable is a variable that we have set upon the creation of the population so it’s a pre-defined variable.
The last step is to check the health of the bfs' by using the method that we define in the subclasses on men and women. When we call this method on bf for example it will take as a parameter the death variable that we had defined in the battle class when we executed the program and this will check if the current health of the bf is less than the death or not. If it is it will return true, if not, false.
If the health is below death we put the bf into the temp stack and remove it later on in the battle class. we do the same thing for the gf as well. After these steps are done, with this we conclude our class club.

THE USER INTERFACE

To explain the software structure of the UI, we will be taking a look at 3 Main classes, StartingSceneController, and Execution. The Main class is used the start the user interface. The first that’s been done is to import needed libraries to be able to run fxml, which are libraries, FXMLLoader, scene, and stage. The javafx. application. Application class provides a framework for managing a JavaFX application, for that to work there needs to be a class that extends it since the class that extends applications srtill be the one executing it. We also need to throw exceptions in the chance of there being an exception existing, the function will throw it out so that the page can be made. In the next few lines, we create the first window, to do that we first need to call dxmlLoader and we use get class and get the resource to get into the class and get the piece of information we want, which in this case “StartingScene.fxml" to start the program and then we load it into a scene. And we set the title of the main stage, which is the frame of the window as “Hello”, the last step is to show the main stage.

The Starting Scene controller will be about the user interface’s main functions, such as sliding controls, and the inputs the viewer will be putting. We import the libraries that are needed for the program to work such as ChangeListener, ObserveValue, ActionEvent, and FXML. After Importing we say StartingSceneController implements Initializable, which means everything in this class will be running all the time with a stop or start. After that, we call the values from the FXML for each of the inputs, which are default values for the default values we set in place, philanderer’s input, faithful input, fast input, and coy input. To make the start button start the function, we make a new class named clickOnStartButton and said throws exceptions again. After that, we say that if the program is not running we have the following conditions. The first one is the case where the default values are selected if that is the case the program will start running and executes the program using the class Execution.

The Execution class allows us to execute the inputs, as the name suggests. The usage of extends Thread is to make sure it works simultaneously with the UI. After that we use this function to set the numbers in the input of the UI to the integer names we set for example this.numberPhilanderers= numberPhilanderers means that the integer numberPhilanderers implemented at the beginning of this class will be equal to int numberPhilanderers set right now. We repeat this step for every variable which is numberFaithful, numberCoy, numberFast, death rate, the death rate(these 2 have - in front of them since the actual numbers of both death rates are negative, we should turn them into positive), mut (for the mutation), approx, rep, year and stability. The next step is to make the execution show the result of the battle. We amme a new battle b and input a,b, c values and other variables to run the program.

After executing the program we say running=false to make the program stop running since It has done what it needed to do. If the chosen option is not the default value, we say else. In this condition we want the viewer to input the values of all 4 of the types and try running the code by using the input values. If we can not use the inputs to calculate the result, there will be an error to say that we use catch. And say wrong input(Error) which is a class at the very end of this class and opens up an alert page. Alert will pop up on the screen with the set title ”Wrong Input”, won’t be resizable, and the box that popped up it’ll say “The values given are Wrong” which will be followed with “Error” + Error(which is the string error’s contents). After this, the program will start running again and execute the program with new inputs and it’ll start running again with the new given values, then stop running. After that, we will be calling the values from FXML again, but this time we do it to make the slider part of the UI, which are Slider maleDeathRateSlider, Label maleDeathRateDisplay, int death rate, Slider maleMutationSlider, Label maleMutationDisplay, int mut, Slider femaleDeathRateSlide, Label femaleDeathRateDisplay, int death rate, Slider approxSlider, Label approxDisplay, int approx, Slider repSlider, Label repDisplay, int rep, Slider year slider, Label year display, int year, Slider stabilitySlider, Label stability display, and int stability. These are every single slider’s slider, label, and the associated integer that we use when we use the slider.

The initialize function is used once again to make the sliders. The reason we use the initialize function is, again, to ensure that the action we wrote will be able to function anytime without a stop or a start. In the next part, we will be using addListener to observe the changes made in the slider after that we’ll use the change method for the new value to be taken from the slider and use a label next to the slider with a “%” at the end of it, with this way we will be able to use the slider and see what percentage of the number we choose. This procedure is repeated for every slider which are both female and male death rate, mutation, approximate, repetition, year, and stability sliders. And at the end, the exit window will pop up, and we do that by using a stage and then using .getScene and .getWindow. The window will show the string "Program Closed” and then the stage is closed.

In the resource and then the selfish gene package, we have all of the variables, slides, integers, and labels that were called by the FXML. As well as the dimensions of the boxes we enter the inputs, and the start and stop buttons, so everything FXML uses is stored here.
